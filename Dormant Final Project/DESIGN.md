# How to run on your computer
Download all the files and add them to your IDE (Coding Environment). Open the terminal (assuming you are on CS50's IDE, you should already have flask installed). Then, simply cd Dormant and then run flask run. You should see a URL in your terminal. Press it. 

# Welcome to Dormant at Yale. . . üõå (Design Edition)
This page is designed to give the more technical version of the README.md, including certain deisgn choices, how things were implemented, and the overall backend functionality of the program. While this design page will be taking a tour of the entire website and program, note that the purpose of this page is to give a more "under the hood" look into the program, rather than a surface level description of what is occuring.

# Layout. . . üñ•Ô∏è
The website/program is designed as a flask program, meaning it uses Python, Flask, and Jinja on the backend, whereas the front end contains Javascript, HTML, and CSS. The main design is from the layouts page, which essentially includes a navigation bar and a clickable link into each of the pages. This is done via html's nav feature, which allows you to link other HTML pages by the user's click of a button. Each page has its own functionality, but the layouts page is the general skeleton of each page's look and feel.


## Getting Started. . . üèÅ
When you open the website, you should land on the index page, which is essentially a greeting to the user. From there, you will see the **Register** and **Log In** page. Because these are in the navigation bar, you can easily click on of the buttons and will be directed into either Register.html or Login.html. Another great feature of the layout bar is that Jinja is used to restrict viewing of other tabs unless you are logged in. For example, because I used **sessions** in the app.py page, unless you are registered in a session, buttons like **find a roommate** or **log out** will be hidden from view. Unless you are logged into the page and your session is saved, you won't be able to see other buttons besides the log in and register one.

### Registering for an account
When you register for an account, you will see a gif made from canva greeting you and telling you to register from an account. From there, you should see three boxes, which are essentially made from the register.html page. You must enter your name, user email, and password, in the text box which uses html's type=input feature, letting the computer know that whatever the user is about to type in will likely be significant later. Indeed, once you hit the submit button at the end (also made from HTML), the computer will register your request as a POST request. Then, it will tell app.py to run everything under the "if request.method == "POST"". In this case, the code that will be run is a db.execute(), meaning that your name, email, and password will be loaded into a SQL database. The reason for this is explained in the next step **Logging In**.

### Logging In
Now that the code of db.execute() ran because you submitted your name and email, your credentials (that is your name, email, and password) will be in a database. Using similar design from the registering for an account, the login.html page has two input fields, your email and your password. It uses the type = input feature so that app.py can grab it later on. And indeed, once you press submit (ie the computer gets a POST request), a query is executed to see if your password entered matches the username in the database. If it does, congrats, you will now be directed to the manual page. If it does not, there are two possibilities: first, it checks to see whether the username/email even exists to begin with. How this is done is via "SELECT * from users.db WHERE email = ?", email. Now, if we suppose the username exists, then we should get a list of length 1 back since the unqiue email/username will have to be 1 row long in details. If this fails, then you are brought back to the register page where you will have to make an account and log in all over again. If the account is registered, then that could only mean the password you entered it wrong, so you will be directed to a page that says password failure (ie you misspelt it, entered it wrong, etc.)

## Manual Page. . . üìö
The manual page is a simply made HTML file that uses the standard <div>, <p> etc. It's main goal is to describe the next steps you should take in order to continue with the application. Because this page does not have any user interaction (as it only lists out the next steps for you), it does not have any significant code to analyze in app.py. Nevertheless, it is useful from a user standpoint because it tells them what to do next.

## Filling out the Preference Form. . . ‚òëÔ∏è
This page is an extremely crucial page to the app, and one that is probably going to be in most detail due to the technicality of it. Here, you see 10 different questions made from the same input feature from HTML. Questions range from "What time do you wake up" to "What does your weekend look like". Afterwards, you will see a drop down box where you can enter your preferences. I specficially chose to do a drop down box as it is more visually appealing and reduces the distraction of having every single option for users to choose from (overwhelming). Once you press submit, you are now entering the website in the form of a POST request. This will then execute a query to INSERT all of your preferences into a table called preferences. So for example, if you entered your bed time was 8:00pm and assuming you pressed submit, app.py will run a query that INSERTS bed_time into preferences where bed_time = 8:00pm. This is the same algorithm used for the other 9 metrics.

## Getting Matched. . . ‚û°Ô∏è
Once you enter the getting matched page, you automatically trigger a bunch of queries that will get 1 person from the massive list of each matching metric. For example, if you chose that your sleep schedule is 8pm, then you will automatically tirgger a query that will SELECT name FROM preferences where sleep schedule = 8:00pm. This is the basic functionality of it and is repeated for the other 9 metrics, for instance if you wake up at 10:00am, then it will pick someone who wakes up at 10:00 am as well using the same exact query as shown above. Afterwards, there is an overall match feature, which picks the person with the most frequent match to be your ideal match.

## Chat. . . üó£Ô∏è
The chat feature runs via packages from the internet. Using packages like socket.io, there is an embedded function code running on a SQL database that collects your name and message. Every single time you press the chat button, it quieries into it and grabs the name of the user and the message, which is then displayed. It seems like a pretty straight forward functionality thanks to the packages installed.

## Profile. . . üë§
The profile page will allow you to see your current preferences based on what you have entered most lately. This proves useful as it is a tracker to see your current ideal roommate. It works by querying into the preferences table of the database and selecting all of your preferences, and then passing them to the page via jinja syntax. So for instance, it selects Wakeup_time from the table where username = your username and just displays this

## Update Profile. . . üÜï
The update profile functions similarly to the preference form page, except this time it allows you to update your page. Instead of INSERTING INTO, like the preference page would. It will updade your page to now get the new information you put. For example, let's say in your initial database your sleep schedule was at 10pm. If you begin to sleep at 8pm now, you can simply enter it into the appropriate field and upon clicking submit, you will run a post request that will run an UPDATE query and substitute whatever you entered into your previous preference. You should be able to press profile page and view that new preference assuming that it operated correctly. Furthermore, you will have the option to see your new roommates by clicking get matched again. 

## Log out . . . üëã
The log out is perhaps the most easiest and straightforward to explain in technicality. Essentially, it clears your session and returns you to the log in page.